<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>希望生活越来越好</title>
  
  <subtitle>Hope life better</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.hjliao.cn/"/>
  <updated>2020-07-22T14:54:40.856Z</updated>
  <id>http://www.hjliao.cn/</id>
  
  <author>
    <name>hjliao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java设计模式：单例模式（双重检查）</title>
    <link href="http://www.hjliao.cn/2020/07/22/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%8F%8C%E9%87%8D%E6%A3%80%E6%9F%A5%EF%BC%89/"/>
    <id>http://www.hjliao.cn/2020/07/22/Java设计模式：单例模式（双重检查）/</id>
    <published>2020-07-22T14:54:40.000Z</published>
    <updated>2020-07-22T14:54:40.856Z</updated>
    
    <content type="html"><![CDATA[<p><strong>双重检查(Double Check）<br>本方法通过两次判断避免线程不安全，通过volatile关键字强制从公共堆栈获取变量，避免从私有线程获取数据<br>优点：懒加载，线程安全，效率较高<br>实际开发中推荐此方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleInstance</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            Singleton instance2 = Singleton.getInstance();</span><br><span class="line">            System.out.println(instance2.hashCode());</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            Singleton instance1 = Singleton.getInstance();</span><br><span class="line">            System.out.println(instance1.hashCode());</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//构造器私有化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//本类内部创建对象实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供公有静态方法，返回实例对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">            <span class="keyword">if</span>(instance==<span class="keyword">null</span>)</span><br><span class="line">                instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;双重检查(Double Check）&lt;br&gt;
本方法通过两次判断避免线程不安全，通过volatile关键字强制从公共堆栈获取变量，避免从私有线程获取数据&lt;br&gt;
优点：懒加载，线程安全，效率较高&lt;br&gt;
实际开发中推荐此方法&lt;/strong&gt;&lt;/p&gt;
&lt;fi
      
    
    </summary>
    
      <category term="设计模式" scheme="http://www.hjliao.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Java" scheme="http://www.hjliao.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Java/"/>
    
    
      <category term="设计模式" scheme="http://www.hjliao.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式：单例模式（枚举）</title>
    <link href="http://www.hjliao.cn/2020/07/22/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%88%E6%9E%9A%E4%B8%BE%EF%BC%89/"/>
    <id>http://www.hjliao.cn/2020/07/22/Java设计模式：单例模式（枚举）/</id>
    <published>2020-07-22T14:15:52.000Z</published>
    <updated>2020-07-22T14:18:16.014Z</updated>
    
    <content type="html"><![CDATA[<p>JDK1.5后用enum枚举类型实现单例模式<br>优点：避免多线程同步问题，防止反序列化重新创建新的对象<br>推荐使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleInstance</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            Singleton instance2 = Singleton.Instance;</span><br><span class="line">            System.out.println(instance2.hashCode());</span><br><span class="line">            instance2.SayHello();</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            Singleton instance1 = Singleton.Instance;</span><br><span class="line">            System.out.println(instance1.hashCode());</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">enum</span> Singleton&#123;</span><br><span class="line">    Instance;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SayHello</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello world"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;JDK1.5后用enum枚举类型实现单例模式&lt;br&gt;
优点：避免多线程同步问题，防止反序列化重新创建新的对象&lt;br&gt;
推荐使用&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;sp
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java设计模式：单例模式（静态内部类）</title>
    <link href="http://www.hjliao.cn/2020/07/22/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%88%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%89/"/>
    <id>http://www.hjliao.cn/2020/07/22/Java设计模式：单例模式（静态内部类）/</id>
    <published>2020-07-22T14:02:58.000Z</published>
    <updated>2020-07-22T14:07:28.757Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本方法采用静态内部类实现，使用JVM装载机制保证初始化时只有一个实例变量，这种方法在装载时不会立即实例化，而是在需要的时候实例化.JVM保证了在类装载的时候，别的线程无法进入<br>优点：线程安全，延迟加载，效率高<br>推荐使用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleInstance</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            Singleton instance2 = Singleton.getInstance();</span><br><span class="line">            System.out.println(instance2.hashCode());</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            Singleton instance1 = Singleton.getInstance();</span><br><span class="line">            System.out.println(instance1.hashCode());</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//构造器私有化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态内部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonInstance</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton Instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonInstance.Instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;本方法采用静态内部类实现，使用JVM装载机制保证初始化时只有一个实例变量，这种方法在装载时不会立即实例化，而是在需要的时候实例化.JVM保证了在类装载的时候，别的线程无法进入&lt;br&gt;
优点：线程安全，延迟加载，效率高&lt;br&gt;
推荐使用&lt;/strong&gt;&lt;/p
      
    
    </summary>
    
      <category term="设计模式" scheme="http://www.hjliao.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Java" scheme="http://www.hjliao.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Java/"/>
    
    
      <category term="设计模式" scheme="http://www.hjliao.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式：单例模式（懒汉模式）</title>
    <link href="http://www.hjliao.cn/2020/07/22/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%88%E6%87%92%E6%B1%89%E6%A8%A1%E5%BC%8F%EF%BC%89/"/>
    <id>http://www.hjliao.cn/2020/07/22/Java设计模式：单例模式（懒汉模式）/</id>
    <published>2020-07-22T13:11:15.000Z</published>
    <updated>2020-07-22T14:31:49.148Z</updated>
    
    <content type="html"><![CDATA[<p><strong>懒汉模式<br>1.线程不安全懒汉模式</strong><br>优点：懒加载<br>缺点：线程不安全，只能在单线程使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//懒汉模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleInstance</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            Singleton instance2 = Singleton.getInstance();</span><br><span class="line">            System.out.println(instance2.hashCode());</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            Singleton instance1 = Singleton.getInstance();</span><br><span class="line">            System.out.println(instance1.hashCode());</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//构造器私有化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//本类内部创建对象实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供公有静态方法，返回实例对象,此方法线程不安全</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.线程安全懒汉模式</strong><br>本方法使用synchronized关键字同步<br>优点：线程安全<br>缺点：效率太低</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleInstance</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            Singleton instance2 = Singleton.getInstance();</span><br><span class="line">            System.out.println(instance2.hashCode());</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            Singleton instance1 = Singleton.getInstance();</span><br><span class="line">            System.out.println(instance1.hashCode());</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//构造器私有化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//本类内部创建对象实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供公有静态方法，返回实例对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.同步代码块懒汉模式</strong><br>本方法采用同步代码块方式实现，是对上方法的改进，但是线程不安全</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleInstance</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            Singleton instance2 = Singleton.getInstance();</span><br><span class="line">            System.out.println(instance2.hashCode());</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            Singleton instance1 = Singleton.getInstance();</span><br><span class="line">            System.out.println(instance1.hashCode());</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//构造器私有化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//本类内部创建对象实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供公有静态方法，返回实例对象,此方法线程不安全</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;懒汉模式&lt;br&gt;
1.线程不安全懒汉模式&lt;/strong&gt;&lt;br&gt;
优点：懒加载&lt;br&gt;
缺点：线程不安全，只能在单线程使用&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="设计模式" scheme="http://www.hjliao.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Java" scheme="http://www.hjliao.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Java/"/>
    
    
      <category term="设计模式" scheme="http://www.hjliao.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式：单例模式（饿汉模式）</title>
    <link href="http://www.hjliao.cn/2020/07/22/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%88%E9%A5%BF%E6%B1%89%E6%A8%A1%E5%BC%8F%EF%BC%89/"/>
    <id>http://www.hjliao.cn/2020/07/22/Java设计模式：单例模式（饿汉模式）/</id>
    <published>2020-07-22T03:42:06.000Z</published>
    <updated>2020-07-22T04:13:00.969Z</updated>
    
    <content type="html"><![CDATA[<p>饿汉模式：<br>优点：采用静态变量，在类装载的时候完成实例化，避免了线程同步问题<br>缺点：在类装载的时候完成实例化，没有达到Lazy loading的效果，如果从始至终未使用过这个类，会造成内存的浪费</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//饿汉模式（静态变量）</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleInstance1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Singleton instance1 = Singleton.getInstance();</span><br><span class="line">        Singleton instance2 = Singleton.getInstance();</span><br><span class="line">        System.out.println(instance1==instance2);</span><br><span class="line">        System.out.println(instance1.hashCode());</span><br><span class="line">        System.out.println(instance2.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//构造器私有化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//本类内部创建对象实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="comment">//提供公有静态方法，返回实例对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>采用静态代码块方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//饿汉模式（静态变量）</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleInstance1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Singleton instance1 = Singleton.getInstance();</span><br><span class="line">        Singleton instance2 = Singleton.getInstance();</span><br><span class="line">        System.out.println(instance1 == instance2);</span><br><span class="line">        System.out.println(instance1.hashCode());</span><br><span class="line">        System.out.println(instance2.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//构造器私有化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//本类内部创建对象实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="comment">//静态代码块内初始化</span></span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//提供公有静态方法，返回实例对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;饿汉模式：&lt;br&gt;
优点：采用静态变量，在类装载的时候完成实例化，避免了线程同步问题&lt;br&gt;
缺点：在类装载的时候完成实例化，没有达到Lazy loading的效果，如果从始至终未使用过这个类，会造成内存的浪费&lt;/p&gt;
&lt;figure class=&quot;highlight ja
      
    
    </summary>
    
      <category term="设计模式" scheme="http://www.hjliao.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Java" scheme="http://www.hjliao.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Java/"/>
    
    
      <category term="设计模式" scheme="http://www.hjliao.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>七大设计原则</title>
    <link href="http://www.hjliao.cn/2020/07/21/%E4%B8%83%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    <id>http://www.hjliao.cn/2020/07/21/七大设计原则/</id>
    <published>2020-07-21T06:35:44.000Z</published>
    <updated>2020-07-21T08:53:51.248Z</updated>
    
    <content type="html"><![CDATA[<p><strong>设计的七大原则分别是：<br>单一职责原则，接口隔离原则，依赖倒转原则，里氏原则，开闭原则，合成复用原则，迪米特法则</strong><br><strong>&gt; 设计原则的目的是使程序或者框架达到低耦合高内聚、便于扩展的目的。</strong><br><strong>1.   开闭原则(Open-Closed Principle, OCP)</strong></p><p>定义：软件实体应当对扩展开放，对修改关闭。这句话说得有点专业，更通俗一点讲，也就是：软件系统中包含的各种组件，例如模块（Modules）、类（Classes）以及功能（Functions）等等，应该在不修改现有代码的基础上，去扩展新功能。开闭原则中原有“开”，是指对于组件功能的扩展是开放的，是允许对其进行功能扩展的；开闭原则中“闭”，是指对于代码的修改是封闭的，即不应该修改原有的代码。</p><p>问题由来：凡事的产生都有缘由。我们来看看，开闭原则的产生缘由。在软件的生命周期内，因为变化、升级和维护等原因需要对软件原有代码进行修改时，可能会给旧代码中引入错误，也可能会使我们不得不对整个功能进行重构，并且需要原有代码经过重新测试。这就对我们的整个系统的影响特别大，这也充分展现出了系统的耦合性如果太高，会大大的增加后期的扩展，维护。为了解决这个问题，故人们总结出了开闭原则。解决开闭原则的根本其实还是在解耦合。所以，我们面向对象的开发，我们最根本的任务就是解耦合。</p><p>解决方法：当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。</p><p>小结：开闭原则具有理想主义的色彩，说的很抽象，它是面向对象设计的终极目标。其他几条原则，则可以看做是开闭原则的实现。我们要用抽象构建框架，用实现扩展细节。<br><strong>2.    单一职责原则（Single Responsibility Principle）</strong></p><p>定义：一个类，只有一个引起它变化的原因。即：应该只有一个职责。</p><p>每一个职责都是变化的一个轴线，如果一个类有一个以上的职责，这些职责就耦合在了一起。这会导致脆弱的设计。当一个职责发生变化时，可能会影响其它的职责。另外，多个职责耦合在一起，会影响复用性。例如：要实现逻辑和界面的分离。需要说明的一点是单一职责原则不只是面向对象编程思想所特有的，只要是模块化的程序设计，都需要遵循这一重要原则。</p><p>问题由来：类T负责两个不同的职责：职责P1，职责P2。当由于职责P1需求发生改变而需要修改类T时，有可能会导致原本运行正常的职责P2功能发生故障。</p><p>解决方法：分别建立两个类T1、T2，使T1完成职责P1功能，T2完成职责P2功能。这样，当修改类T1时，不会使职责P2发生故障风险；同理，当修改T2时，也不会使职责P1发生故障风险。</p><p><strong>3.    里氏替换原则（Liskov Substitution Principle）</strong></p><p>定义：子类型必须能够替换掉它们的父类型。注意这里的能够两字。有人也戏称老鼠的儿子会打洞原则。</p><p>问题由来：有一功能P1，由类A完成。现需要将功能P1进行扩展，扩展后的功能为P，其中P由原有功能P1与新功能P2组成。新功能P由类A的子类B来完成，则子类B在完成新功能P2的同时，有可能会导致原有功能P1发生故障。</p><p>解决方法：类B继承类A时，除添加新的方法完成新增功能P2外，尽量不要重写父类A的方法，也尽量不要重载父类A的方法</p><p>小结：所有引用父类的地方必须能透明地使用其子类的对象。子类可以扩展父类的功能，但不能改变父类原有的功能，即：子类可以实现父类的抽象方法，子类也中可以增加自己特有的方法，但不能覆盖父类的非抽象方法。当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。<br><strong>4.    迪米特法则（最小知道原则）（Law Of Demeter）</strong></p><p>定义：迪米特法则又叫最少知道原则，即：一个对象应该对其他对象保持最少的了解。如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。简单定义为只与直接的朋友通信。首先来解释一下什么是直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖、关联、组合、聚合等。其中，我们称出现成员变量、方法参数、方法返回值中的类为直接的朋友，而出现在局部变量中的类则不是直接的朋友。也就是说，陌生的类最好不要作为局部变量的形式出现在类的内部。</p><p>问题由来：类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。</p><p>最早是在1987年由美国Northeastern University的Ian Holland提出。通俗的来讲，就是一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类来说，无论逻辑多么复杂，都尽量地的将逻辑封装在类的内部，对外除了提供的public方法，不对外泄漏任何信息。迪米特法则还有一个更简单的定义：只与直接的朋友通信。</p><p>解决方法：尽量降低类与类之间的耦合。 自从我们接触编程开始，就知道了软件编程的总的原则：低耦合，高内聚。无论是面向过程编程还是面向对象编程，只有使各个模块之间的耦合尽量的低，才能提高代码的复用率。</p><p>迪米特法则的初衷是降低类之间的耦合，由于每个类都减少了不必要的依赖，因此的确可以降低耦合关系。但是凡事都有度，虽然可以避免与非直接的类通信，但是要通信，必然会通过一个“中介”来发生联系。故过分的使用迪米特原则，会产生大量这样的中介和传递类，导致系统复杂度变大。所以在采用迪米特法则时要反复权衡，既做到结构清晰，又要高内聚低耦合。</p><p><strong>5.    依赖倒置原则（Dependence Inversion Principle）</strong></p><p>定义：高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。中心思想是面向接口编程</p><p>问题由来：类A直接依赖类B，假如要将类A改为依赖类C，则必须通过修改类A的代码来达成。这种场景下，类A一般是高层模块，负责复杂的业务逻辑；类B和类C是低层模块，负责基本的原子操作；假如修改类A，会给程序带来不必要的风险。</p><p>解决方法：将类A修改为依赖接口I，类B和类C各自实现接口I，类A通过接口I间接与类B或者类C发生联系，则会大大降低修改类A的几率。</p><p>在实际编程中，我们一般需要做到如下3点：</p><p>1）. 低层模块尽量都要有抽象类或接口，或者两者都有。</p><p>2）. 变量的声明类型尽量是抽象类或接口。</p><p>3）. 使用继承时遵循里氏替换原则。</p><p>采用依赖倒置原则尤其给多人合作开发带来了极大的便利，参与协作开发的人越多、项目越庞大，采用依赖导致原则的意义就越重大。</p><p>小结：依赖倒置原则就是要我们面向接口编程，理解了面向接口编程，也就理解了依赖倒置。<br><strong>6.    接口隔离原则（Interface Segregation Principle）</strong></p><p>定义：客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。</p><p>问题由来：类A通过接口I依赖类B，类C通过接口I依赖类D，如果接口I对于类A和类B来说不是最小接口，则类B和类D必须去实现他们不需要的方法</p><p>解决方法：1、 使用委托分离接口。2、 使用多重继承分离接口。3.将臃肿的接口I拆分为独立的几个接口，类A和类C分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则</p><p>小结：我们在代码编写过程中，运用接口隔离原则，一定要适度，接口设计的过大或过小都不好。对接口进行细化可以提高程序设计灵活性是不挣的事实，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度。设计接口的时候，只有多花些时间去思考和筹划，就能准确地实践这一原则。</p><p><strong>7.   合成/聚合原则（合成复用原则）(Composite/Aggregate Reuse Principle,CARP)</strong></p><p>定义：也有人叫做合成复用原则，及尽量使用合成/聚合，尽量不要使用类继承。换句话说，就是能用合成/聚合的地方，绝不用继承。</p><p>为什么要尽量使用合成/聚合而不使用类继承？</p><ol><li><p>对象的继承关系在编译时就定义好了，所以无法在运行时改变从父类继承的子类的实现</p></li><li><p>子类的实现和它的父类有非常紧密的依赖关系，以至于父类实现中的任何变化必然会导致子类发生变化</p></li><li><p>当你复用子类的时候，如果继承下来的实现不适合解决新的问题，则父类必须重写或者被其它更适合的类所替换，这种依赖关系限制了灵活性，并最终限制了复用性。</p></li></ol><p>总结：这些原则在设计模式中体现的淋淋尽致，设计模式就是实现了这些原则，从而达到了代码复用、增强了系统的扩展性。所以设计模式被很多人奉为经典。我们可以通过好好的研究设计模式，来慢慢的体会这些设计原则</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;设计的七大原则分别是：&lt;br&gt;
单一职责原则，接口隔离原则，依赖倒转原则，里氏原则，开闭原则，合成复用原则，迪米特法则&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;&amp;gt; 设计原则的目的是使程序或者框架达到低耦合高内聚、便于扩展的目的。&lt;/strong&gt;&lt;b
      
    
    </summary>
    
      <category term="Java" scheme="http://www.hjliao.cn/categories/Java/"/>
    
      <category term="设计原则" scheme="http://www.hjliao.cn/categories/Java/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    
    
      <category term="设计原则" scheme="http://www.hjliao.cn/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="http://www.hjliao.cn/2020/02/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.hjliao.cn/2020/02/16/设计模式/</id>
    <published>2020-02-16T10:00:11.000Z</published>
    <updated>2020-02-16T10:00:30.996Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/2020/02/16/15cfc250-50a3-11ea-bca7-9dada1bf3f3f.png" alt="image.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/2020/02/16/15cfc250-50a3-11ea-bca7-9dada1bf3f3f.png&quot; alt=&quot;image.png&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="Java" scheme="http://www.hjliao.cn/categories/Java/"/>
    
    
      <category term="Java" scheme="http://www.hjliao.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>牧童诗</title>
    <link href="http://www.hjliao.cn/2020/02/05/%E7%89%A7%E7%AB%A5%E8%AF%97/"/>
    <id>http://www.hjliao.cn/2020/02/05/牧童诗/</id>
    <published>2020-02-05T14:33:15.000Z</published>
    <updated>2020-02-05T14:33:15.932Z</updated>
    
    <content type="html"><![CDATA[<p>牧童诗<br>——黄庭坚<br>骑牛远远过前村，短笛横吹隔陇闻。</p><p>多少长安名利客，机关用尽不如君。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;牧童诗&lt;br&gt;
——黄庭坚&lt;br&gt;
骑牛远远过前村，短笛横吹隔陇闻。&lt;/p&gt;
&lt;p&gt;多少长安名利客，机关用尽不如君。&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>破解学习（一）</title>
    <link href="http://www.hjliao.cn/2019/12/15/%E7%A0%B4%E8%A7%A3%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://www.hjliao.cn/2019/12/15/破解学习（一）/</id>
    <published>2019-12-15T11:59:13.000Z</published>
    <updated>2019-12-15T12:08:45.538Z</updated>
    
    <content type="html"><![CDATA[<p>首先检查软件是否加壳，如没有，则相对简单。</p><p>涉及到简单的程序，可以修改相应校验跳转程序，跳过校验。<br>如果是程序生成激活码，可以直接在内存中读到对应值，来激活。</p><p>exe程序初始地址：00401000<br><strong>查壳软件：PEid<br>破解软件：ollydbg</strong></p><p><img src="/images/2019/12/15/39984dd0-1f32-11ea-9849-dd5291ac14de.png" alt="image.png"></p><p>1.查壳</p><p>2.寻找关键字或断点</p><p>3.找到关键跳转或者关键call</p><p>4.修改达到破解的目的</p><p>ctrl+g     输入00401000来到程序的入口点</p><p>ctrl+f     输入要查找的信息</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先检查软件是否加壳，如没有，则相对简单。&lt;/p&gt;
&lt;p&gt;涉及到简单的程序，可以修改相应校验跳转程序，跳过校验。&lt;br&gt;
如果是程序生成激活码，可以直接在内存中读到对应值，来激活。&lt;/p&gt;
&lt;p&gt;exe程序初始地址：00401000&lt;br&gt;
&lt;strong&gt;查壳软件：PEi
      
    
    </summary>
    
      <category term="破解" scheme="http://www.hjliao.cn/categories/%E7%A0%B4%E8%A7%A3/"/>
    
    
      <category term="脱壳" scheme="http://www.hjliao.cn/tags/%E8%84%B1%E5%A3%B3/"/>
    
      <category term="破解" scheme="http://www.hjliao.cn/tags/%E7%A0%B4%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>并发起来采用静态变量的坑</title>
    <link href="http://www.hjliao.cn/2019/12/10/%E5%B9%B6%E5%8F%91%E8%B5%B7%E6%9D%A5%E9%87%87%E7%94%A8%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E7%9A%84%E5%9D%91/"/>
    <id>http://www.hjliao.cn/2019/12/10/并发起来采用静态变量的坑/</id>
    <published>2019-12-10T00:00:23.000Z</published>
    <updated>2019-12-10T00:00:23.642Z</updated>
    
    <content type="html"><![CDATA[<p>如果静态变量涉及到修改的话，尽量不要在并发环境使用，极有可能会导致错乱。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;如果静态变量涉及到修改的话，尽量不要在并发环境使用，极有可能会导致错乱。&lt;/p&gt;

      
    
    </summary>
    
      <category term="Java" scheme="http://www.hjliao.cn/categories/Java/"/>
    
    
      <category term="Java" scheme="http://www.hjliao.cn/tags/Java/"/>
    
      <category term="静态变量" scheme="http://www.hjliao.cn/tags/%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F/"/>
    
      <category term="并发" scheme="http://www.hjliao.cn/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>（每日一题）两数之和</title>
    <link href="http://www.hjliao.cn/2019/11/26/%EF%BC%88%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%89%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>http://www.hjliao.cn/2019/11/26/（每日一题）两数之和/</id>
    <published>2019-11-26T15:34:47.000Z</published>
    <updated>2019-11-26T15:35:05.803Z</updated>
    
    <content type="html"><![CDATA[<p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</p><p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p><p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p>示例：</p><p>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>输出：7 -&gt; 0 -&gt; 8<br>原因：342 + 465 = 807</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    ListNode dummyHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode p = l1, q = l2, curr = dummyHead;</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span> || q != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = (p != <span class="keyword">null</span>) ? p.val : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> y = (q != <span class="keyword">null</span>) ? q.val : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = carry + x + y;</span><br><span class="line">        carry = sum / <span class="number">10</span>;</span><br><span class="line">        curr.next = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">        curr = curr.next;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="keyword">null</span>) p = p.next;</span><br><span class="line">        <span class="keyword">if</span> (q != <span class="keyword">null</span>) q = q.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (carry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        curr.next = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。&lt;/p&gt;
&lt;p&gt;如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。&lt;/p&gt;
&lt;p&gt;您可以假设除了数字 0 之外，这两个数都不
      
    
    </summary>
    
      <category term="算法" scheme="http://www.hjliao.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://www.hjliao.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="每日一题" scheme="http://www.hjliao.cn/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>（每日一题）算法</title>
    <link href="http://www.hjliao.cn/2019/11/25/%EF%BC%88%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%89%E7%AE%97%E6%B3%95/"/>
    <id>http://www.hjliao.cn/2019/11/25/（每日一题）算法/</id>
    <published>2019-11-25T15:35:25.000Z</published>
    <updated>2019-11-25T16:00:35.057Z</updated>
    
    <content type="html"><![CDATA[<p>从今天开始，每天刷一道算法题，提升自身逻辑能力，先从简单的来<br>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p><p>示例:</p><p>给定 nums = [2, 7, 11, 15], target = 9</p><p>因为 nums[0] + nums[1] = 2 + 7 = 9<br>所以返回 [0, 1]</p><p>最简答粗暴的解法，时间复杂度高：O(n^2)，空间复杂度低O(1)，一般人最直接的想法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length-<span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;nums.length;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]+nums[j]==target)</span><br><span class="line">                &#123;</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i,j&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/2019/11/25/4fb54a10-0f9b-11ea-b0ff-5bdb9aeca405.png" alt="image.png"><br>事实上，由于中间变量，暴力法的内存占用也不低<br>考虑更多的解法：<br>两次哈希，用空间换时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">      Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            map.put(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> <span class="keyword">var</span> = target-nums[i];</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(<span class="keyword">var</span>)&amp;&amp;map.get(<span class="keyword">var</span>)!=i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;i,map.get(<span class="keyword">var</span>)&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/2019/11/25/1ae9f830-0f9b-11ea-b0ff-5bdb9aeca405.png" alt="image.png"><br>事实证明，可以在生成hash的同时，检查是否存在相关值，减少迭代次数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">      Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> <span class="keyword">var</span> = target - nums[i];</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(<span class="keyword">var</span>)&amp;&amp;map.get(<span class="keyword">var</span>)!=i)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i,map.get(<span class="keyword">var</span>)&#125;;</span><br><span class="line">            map.put(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/2019/11/26/a4c8f690-0f9c-11ea-b0ff-5bdb9aeca405.png" alt="image.png"><br>此方法是利用了问题计算的对称性，来减少计算量。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;从今天开始，每天刷一道算法题，提升自身逻辑能力，先从简单的来&lt;br&gt;
给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。&lt;/p&gt;
&lt;p&gt;你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组
      
    
    </summary>
    
      <category term="算法" scheme="http://www.hjliao.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://www.hjliao.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="每日一题" scheme="http://www.hjliao.cn/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>近来所思</title>
    <link href="http://www.hjliao.cn/2019/11/20/%E8%BF%91%E6%9D%A5%E6%89%80%E6%80%9D/"/>
    <id>http://www.hjliao.cn/2019/11/20/近来所思/</id>
    <published>2019-11-20T14:32:23.000Z</published>
    <updated>2020-02-05T14:32:09.956Z</updated>
    
    <content type="html"><![CDATA[<p>好久没更新博客了，一方面是由于工作经常忙到深夜，精力有限，另一方面自己状态也不是特别好。捱过最难过的日子，总会见曙光的，喜欢做的事情还是要坚持做下去呀，学点新东西，拓宽自己的视野。<br>多读几本好书，多看看这个世界，充实自己的灵魂和思想，在最适合自己的年纪做最适合自己的事情，总不会错的~<br>解开了心结，挣扎过后，一切都显得那么释然、轻松。从局外人的身份看待别人的事情时，比谁都理智和清晰，但涉及自身，却优柔寡断、唯唯诺诺，思前想后，过自己的生活最重要呀。<br>希望未来能好好健身，读书，有空的时候多出去走走，看看自然的风光~<br>过好自己的生活就好，念念不忘，岂有回响~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;好久没更新博客了，一方面是由于工作经常忙到深夜，精力有限，另一方面自己状态也不是特别好。捱过最难过的日子，总会见曙光的，喜欢做的事情还是要坚持做下去呀，学点新东西，拓宽自己的视野。&lt;br&gt;
多读几本好书，多看看这个世界，充实自己的灵魂和思想，在最适合自己的年纪做最适合自己的
      
    
    </summary>
    
      <category term="光阴记录" scheme="http://www.hjliao.cn/categories/%E5%85%89%E9%98%B4%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>pyqt基本</title>
    <link href="http://www.hjliao.cn/2019/10/20/pyqt%E5%9F%BA%E6%9C%AC/"/>
    <id>http://www.hjliao.cn/2019/10/20/pyqt基本/</id>
    <published>2019-10-20T13:11:20.000Z</published>
    <updated>2019-10-20T13:11:21.016Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/2019/10/20/1379cc00-f33b-11e9-85a3-6d70c3b8e69d.png" alt="image.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/2019/10/20/1379cc00-f33b-11e9-85a3-6d70c3b8e69d.png&quot; alt=&quot;image.png&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="qt" scheme="http://www.hjliao.cn/categories/qt/"/>
    
    
      <category term="qt" scheme="http://www.hjliao.cn/tags/qt/"/>
    
  </entry>
  
  <entry>
    <title>更换一个hexo编辑器——hexoclient</title>
    <link href="http://www.hjliao.cn/2019/08/24/%E6%9B%B4%E6%8D%A2%E4%B8%80%E4%B8%AAhexo%E7%BC%96%E8%BE%91%E5%99%A8%E2%80%94%E2%80%94hexoclient/"/>
    <id>http://www.hjliao.cn/2019/08/24/更换一个hexo编辑器——hexoclient/</id>
    <published>2019-08-24T02:31:41.000Z</published>
    <updated>2019-08-24T02:33:08.517Z</updated>
    
    <content type="html"><![CDATA[<p>经过亲测，此软件简洁好用，能够自动导入之前的博客数据，基于electron开发，可跨平台，体积也不算大<br>附上码云链接：<a href="https://gitee.com/gaoyoubo/hexo-client" target="_blank" rel="noopener">https://gitee.com/gaoyoubo/hexo-client</a><br><strong>软件下载：<a href="https://github.com/gaoyoubo/hexo-client/releases/download/v1.3.1/HexoClient-Setup-1.3.1.exe" target="_blank" rel="noopener">https://github.com/gaoyoubo/hexo-client/releases/download/v1.3.1/HexoClient-Setup-1.3.1.exe</a></strong><br>同时感谢开发者高尤波</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;经过亲测，此软件简洁好用，能够自动导入之前的博客数据，基于electron开发，可跨平台，体积也不算大&lt;br&gt;
附上码云链接：&lt;a href=&quot;https://gitee.com/gaoyoubo/hexo-client&quot; target=&quot;_blank&quot; rel=&quot;noop
      
    
    </summary>
    
      <category term="hexo" scheme="http://www.hjliao.cn/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://www.hjliao.cn/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>今天，毕业了</title>
    <link href="http://www.hjliao.cn/2019/06/25/%E4%BB%8A%E5%A4%A9%EF%BC%8C%E6%88%91%E6%AF%95%E4%B8%9A%E4%BA%86/"/>
    <id>http://www.hjliao.cn/2019/06/25/今天，我毕业了/</id>
    <published>2019-06-25T14:28:00.000Z</published>
    <updated>2019-08-23T12:36:19.620Z</updated>
    
    <content type="html"><![CDATA[<p>今天，我从待了四年的母校——西南交通大学毕业了，逝去的时光终究是珍贵的，因为它属于过去，不可获得。<br>早上从天佑斋三栋离开，室友还睡眼惺忪地望了我一眼，交代了一些事情，便离开了。我知道，此生再不会踏入036018，和室友深夜聊天。<br>东西都邮寄回去了，不想带着太多东西离开，因为负重的感觉会更让人心情沉重，丢在校园的太多东西已经无法带走，只能留在回忆里。<br>四年转瞬，当我选择了工作而脱离了学生这个身份，我才感觉到在校园的生活是有多么美好，无论是在混日子还是勤奋地学习，都是一样的。<br>因为这段时光属于自己，谁也夺不走。<br>大学四年，仍是孤身一人，获得一些东西时就会失去一些东西，很正常，没有什么好抱怨的，倒是希望之后的日子能够幸逢有缘人。<br>很高兴大学学的专业还算是自己比较喜欢的，未来发展也不错，感谢当初学校的调剂。<br>在学校里，最珍贵的是遇到了很多不同的朋友，能够和他们一起学习、生活很是幸运。<br>感谢四年来的室友们，虽然大家性格各异，兴趣也有所不同，当仍然能够求同存异，一起度过这段时光，希望各自相安，有缘再见！<br>再见了，我的学生时代。<br>再见了，我的西南交大。<br>江湖再见</p><p></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天，我从待了四年的母校——西南交通大学毕业了，逝去的时光终究是珍贵的，因为它属于过去，不可获得。&lt;br&gt;
早上从天佑斋三栋离开，室友还睡眼惺忪地望了我一眼，交代了一些事情，便离开了。我知道，此生再不会踏入036018，和室友深夜聊天。&lt;br&gt;
东西都邮寄回去了，不想带着太
      
    
    </summary>
    
      <category term="光阴记录" scheme="http://www.hjliao.cn/categories/%E5%85%89%E9%98%B4%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="毕业" scheme="http://www.hjliao.cn/tags/%E6%AF%95%E4%B8%9A/"/>
    
      <category term="似水年华" scheme="http://www.hjliao.cn/tags/%E4%BC%BC%E6%B0%B4%E5%B9%B4%E5%8D%8E/"/>
    
  </entry>
  
  <entry>
    <title>百度语音合成集成到QT问题</title>
    <link href="http://www.hjliao.cn/2019/05/01/%E8%AF%AD%E9%9F%B3%E5%90%88%E6%88%90%E9%9B%86%E6%88%90%E5%88%B0QT%E9%97%AE%E9%A2%98/"/>
    <id>http://www.hjliao.cn/2019/05/01/语音合成集成到QT问题/</id>
    <published>2019-05-01T01:52:00.000Z</published>
    <updated>2019-05-01T02:06:31.877Z</updated>
    
    <content type="html"><![CDATA[<p>当我从官方下载了c++的sdk，按照官方说明进行依赖安装，使用时陆续出现了一系列问题，需要注意的是：</p><pre><code>1.编译依赖jsoncpp.openssl.curl依赖需要一致，动态或者静态，debug或者release保持一致，建议动态release版本，静态编译库的话后面curl会出现问题很麻烦，不建议静态编译。2.在pro配置文件中，规定c++版本。3.出现LNK2005或者是MUTIPLE FUNCTION时，直接在对应的头文件中将该函数内联，这是由于该框架函数和qt的Q_OBJECT重定义导致的。</code></pre><p></p><p><img src="/images/image-9.png" alt="upload successful"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当我从官方下载了c++的sdk，按照官方说明进行依赖安装，使用时陆续出现了一系列问题，需要注意的是：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1.编译依赖jsoncpp.openssl.curl依赖需要一致，动态或者静态，debug或者release保持一致，
建议动态release
      
    
    </summary>
    
      <category term="语音合成" scheme="http://www.hjliao.cn/categories/%E8%AF%AD%E9%9F%B3%E5%90%88%E6%88%90/"/>
    
    
      <category term="百度语音合成" scheme="http://www.hjliao.cn/tags/%E7%99%BE%E5%BA%A6%E8%AF%AD%E9%9F%B3%E5%90%88%E6%88%90/"/>
    
      <category term="QT" scheme="http://www.hjliao.cn/tags/QT/"/>
    
  </entry>
  
  <entry>
    <title>Openssl-windows编译说明</title>
    <link href="http://www.hjliao.cn/2019/04/30/Openssl%E5%AE%98%E6%96%B9%E7%BC%96%E8%AF%91%E8%AF%B4%E6%98%8E/"/>
    <id>http://www.hjliao.cn/2019/04/30/Openssl官方编译说明/</id>
    <published>2019-04-30T04:17:00.000Z</published>
    <updated>2019-04-30T05:52:43.886Z</updated>
    
    <content type="html"><![CDATA[<p>on Windows (only pick one of the targets for configuration):</p><pre><code>  $ perl Configure { VC-WIN32 | VC-WIN64A | VC-WIN64I | VC-CE }  $ nmake  $ nmake test  $ nmake install</code></pre><p>在新的vc编译环境下，ms不提供支持了，所以用nmake工具，perl后添加no-shared为编译静态库，默认编译动态库</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;on Windows (only pick one of the targets for configuration):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  $ perl Configure { VC-WIN32 | VC-WIN64A | VC-WIN64I | VC-CE
      
    
    </summary>
    
      <category term="openssl" scheme="http://www.hjliao.cn/categories/openssl/"/>
    
    
      <category term="openssl" scheme="http://www.hjliao.cn/tags/openssl/"/>
    
  </entry>
  
  <entry>
    <title>QT5信号槽连接方式</title>
    <link href="http://www.hjliao.cn/2019/04/13/QT5%E4%BF%A1%E5%8F%B7%E6%A7%BD%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F/"/>
    <id>http://www.hjliao.cn/2019/04/13/QT5信号槽连接方式/</id>
    <published>2019-04-13T05:33:00.000Z</published>
    <updated>2019-04-13T05:38:18.172Z</updated>
    
    <content type="html"><![CDATA[<pre><code>旧的写法：connect(this-&gt;m,SIGNAL(baseonButtonGlobalClickedSignal()),this,SLOT(onButtonGlobalClicked()));</code></pre><p></p><pre><code>新的写法:connect(this-&gt;helpcontent,&amp;QLabelClicked::QLabelClickedSignal,this,&amp;MainWindow::onOpenUrl);注意：不能混用，SIGNAL和SLOT搭配，信号和槽要适配，不能信号用旧的写法， 槽用新的写法。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;旧的写法：
connect(this-&amp;gt;m,SIGNAL(baseonButtonGlobalClickedSignal()),this,SLOT(onButtonGlobalClicked()));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;/p&gt;
&lt;pr
      
    
    </summary>
    
      <category term="qt5" scheme="http://www.hjliao.cn/categories/qt5/"/>
    
    
      <category term="qt5" scheme="http://www.hjliao.cn/tags/qt5/"/>
    
      <category term="信号和槽" scheme="http://www.hjliao.cn/tags/%E4%BF%A1%E5%8F%B7%E5%92%8C%E6%A7%BD/"/>
    
  </entry>
  
  <entry>
    <title>openssl安装问题</title>
    <link href="http://www.hjliao.cn/2019/04/08/enssl%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98/"/>
    <id>http://www.hjliao.cn/2019/04/08/enssl安装问题/</id>
    <published>2019-04-08T14:48:00.000Z</published>
    <updated>2019-04-09T08:43:48.233Z</updated>
    
    <content type="html"><![CDATA[<p>编译openssl过程中出现错误：</p><pre><code>tmp32dll\sha1-586.asm(1432) : error A2070:invalid instruction operandstmp32dll\sha1-586.asm(1576) : error A2070:invalid instruction operands</code></pre><p>由于1.0.2版本过新，导致报错，于是下载1.0.1版本，链接如下：</p><pre><code>    https://www.openssl.org/source/openssl-1.0.1r.tar.gz</code></pre><p>32位安装流程：</p><pre><code>   1.安装perl   2.配置vs开发人工具环境变量   3.打开命令窗口到openssl文件夹下   4.perl configure VC-WIN32   5.ms/do_ms   6.nmake -f ms\ntdll.mak    测试成功：   7.nmake -f ms\ntdll.mak test</code></pre><p>64位安装流程：</p><pre><code>     1.安装perl     2.配置vs开发人工具环境变量     3.打开命令窗口到openssl文件夹下       4.perl Configure debug-VC-WIN64A no-asm --prefix=C:\openssl\lib --openssldir=C:\openssl\bin      5.ms\do_win64a     6.nmake -f ms\ntdll.mak clean     7.nmake -f ms\ntdll.mak      8.nmake -f ms\nt.mak clean     9.nmake -f ms\nt.mak</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;编译openssl过程中出现错误：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;tmp32dll\sha1-586.asm(1432) : error A2070:invalid instruction operands
tmp32dll\sha1-586.asm(1576) : err
      
    
    </summary>
    
      <category term="openssl" scheme="http://www.hjliao.cn/categories/openssl/"/>
    
    
      <category term="openssl" scheme="http://www.hjliao.cn/tags/openssl/"/>
    
      <category term="vs2017" scheme="http://www.hjliao.cn/tags/vs2017/"/>
    
  </entry>
  
</feed>
